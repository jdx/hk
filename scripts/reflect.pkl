/// A PKL script to help output a reflected module.
/// Example Invocation: pkl eval <pkl file> --format json -x 'import("file:/<repopath>/scripts/reflect.pkl").render(module)'
module hk.reflect
import "pkl:reflect"

local renderer = module.output.renderer
function render(mod: Module): String = renderer.renderValue(reflect.Module(mod))

// NB: We reuse module output renderer, so we get the `--format` switching for free.
output {
  renderer {
    converters {
      [reflect.Class] = (c) -> new Dynamic {
        name = c.name
        properties = c.properties
      }
      [reflect.Property] = (p) -> new Dynamic {
        name = p.name
        type = p.type
        docComment = p.docComment
        defaultValue = if (p.name == "output") null else renderer.renderValue(p.defaultValue)
        annnotations = p.annotations
      }
      [reflect.StringLiteralType] = (s) -> s.value
      [reflect.NullableType] = (t) -> "\(outer[t.member.getClass()].apply(t.member))?"
      [reflect.DeclaredType] = (d) ->
        if (d.typeArguments.isEmpty)
          d.referent.name
        else
          "\(d.referent.name)<\(d.typeArguments.map((arg) -> outer[arg.getClass()].apply(arg)).join(", "))>"
      [reflect.UnknownType] = (u) -> "Unknown"
      [reflect.UnionType] = (u) ->
        u.members.map((member) -> outer[member.getClass()].apply(member)).join(" | ")
      [reflect.Type] = (t) -> t.name
    }
  }
}
