use indexmap::IndexMap;
use serde::Deserialize;
use std::collections::BTreeSet;
use std::env;
use std::fmt::Write as FmtWrite;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Deserialize)]
struct SettingsRegistry {
    option: IndexMap<String, OptionConfig>,
}

#[derive(Debug, Deserialize)]
struct OptionConfig {
    #[serde(rename = "type")]
    typ: String,
    default: toml::Value,
    merge: String,
    sources: Sources,
    docs: String,
    #[serde(default)]
    validate: Validate,
}

#[derive(Debug, Default, Deserialize)]
struct Sources {
    #[serde(default)]
    pkl: SourceDef,
    #[serde(default)]
    env: Vec<String>,
    #[serde(default)]
    git: Vec<String>,
    #[serde(default)]
    cli: Vec<String>,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum SourceDef {
    Single(String),
    Multiple(Vec<String>),
}

impl Default for SourceDef {
    fn default() -> Self {
        SourceDef::Multiple(vec![])
    }
}

impl SourceDef {
    fn as_vec(&self) -> Vec<String> {
        match self {
            SourceDef::Single(s) => vec![s.clone()],
            SourceDef::Multiple(v) => v.clone(),
        }
    }
}

#[derive(Debug, Default, Deserialize)]
struct Validate {
    #[serde(rename = "enum", default)]
    enum_values: Vec<String>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var_os("OUT_DIR").unwrap());

    // Generate builtins
    builtins(&out_dir)?;

    // Generate settings code
    generate_settings()?;

    Ok(())
}

fn builtins(out_dir: &Path) -> Result<(), std::io::Error> {
    let dest_path = Path::new(&out_dir).join("builtins.rs");

    let builtins_dir = Path::new("pkl/builtins");
    let builtins = ls(builtins_dir)?
        .into_iter()
        .filter_map(|f| f.strip_suffix(".pkl").map(|s| s.to_string()))
        .collect::<BTreeSet<String>>();

    let code = format!(
        "pub const BUILTINS: &[&str] = &[{}];",
        builtins
            .iter()
            .map(|b| format!("\"{b}\""))
            .collect::<Vec<String>>()
            .join(", ")
    );

    fs::write(dest_path, code)?;
    println!("cargo:rerun-if-changed=pkl/builtins");
    Ok(())
}

fn ls(path: &Path) -> Result<Vec<String>, std::io::Error> {
    let mut files = Vec::new();
    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let file_name = entry.file_name();
        files.push(file_name.to_string_lossy().to_string());
    }
    Ok(files)
}

fn generate_settings() -> Result<(), Box<dyn std::error::Error>> {
    // Only generate if settings.toml exists
    let settings_path = Path::new("settings.toml");
    if !settings_path.exists() {
        // Skip generation if file doesn't exist yet
        return Ok(());
    }

    println!("cargo:rerun-if-changed=settings.toml");

    let settings_toml = fs::read_to_string("settings.toml")?;
    let registry: SettingsRegistry = toml::from_str(&settings_toml)?;

    // Create generated directory
    let gen_dir = Path::new("src/config/generated");
    fs::create_dir_all(gen_dir)?;

    // Generate settings struct
    generate_settings_struct(&registry, gen_dir)?;

    // Generate CLI flags
    generate_cli_flags(&registry, gen_dir)?;

    // Generate git config reader
    generate_git_config(&registry, gen_dir)?;

    // Generate documentation
    generate_docs(&registry)?;

    Ok(())
}

fn generate_settings_struct(
    registry: &SettingsRegistry,
    gen_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();

    // Header
    writeln!(code, "// THIS FILE IS AUTO-GENERATED - DO NOT EDIT")?;
    writeln!(code, "// Generated by build.rs from settings.toml")?;
    writeln!(code)?;
    writeln!(code, "#![allow(dead_code)]")?;
    writeln!(code, "#![allow(unused_imports)]")?;
    writeln!(code)?;
    writeln!(code, "use indexmap::IndexSet;")?;
    writeln!(code, "use std::collections::HashMap;")?;
    writeln!(code, "use std::num::NonZero;")?;
    writeln!(code, "use std::path::PathBuf;")?;
    writeln!(code)?;

    // Settings struct
    writeln!(code, "#[derive(Debug, Clone)]")?;
    writeln!(code, "pub struct GeneratedSettings {{")?;

    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        let field_type = rust_type(&opt.typ, name);
        writeln!(code, "    /// {}", opt.docs)?;
        writeln!(code, "    pub {}: {},", field_name, field_type)?;
    }

    writeln!(code, "}}")?;
    writeln!(code)?;

    // Source tracking struct
    writeln!(code, "#[derive(Debug, Clone)]")?;
    writeln!(code, "pub struct SettingsSources {{")?;
    writeln!(code, "    /// Map of field name to source description")?;
    writeln!(code, "    pub sources: HashMap<String, String>,")?;
    writeln!(code, "}}")?;
    writeln!(code)?;

    // SettingsBuilder
    writeln!(code, "pub struct SettingsBuilder {{")?;
    writeln!(code, "    // Store values by precedence layer")?;
    writeln!(code, "    defaults: LayerValues,")?;
    writeln!(code, "    pkl: LayerValues,")?;
    writeln!(code, "    git: LayerValues,")?;
    writeln!(code, "    env: LayerValues,")?;
    writeln!(code, "    cli: LayerValues,")?;
    writeln!(code, "    sources: HashMap<String, String>,")?;
    writeln!(code, "}}")?;
    writeln!(code)?;

    writeln!(code, "#[derive(Default)]")?;
    writeln!(code, "struct LayerValues {{")?;
    for (name, _) in &registry.option {
        let field_name = name.replace('-', "_");
        writeln!(code, "    {}: Option<toml::Value>,", field_name)?;
    }
    writeln!(code, "}}")?;
    writeln!(code)?;

    // Builder implementation
    writeln!(code, "impl SettingsBuilder {{")?;
    writeln!(code, "    pub fn new() -> Self {{")?;
    writeln!(code, "        let mut builder = Self {{")?;
    writeln!(code, "            defaults: LayerValues::default(),")?;
    writeln!(code, "            pkl: LayerValues::default(),")?;
    writeln!(code, "            git: LayerValues::default(),")?;
    writeln!(code, "            env: LayerValues::default(),")?;
    writeln!(code, "            cli: LayerValues::default(),")?;
    writeln!(code, "            sources: HashMap::new(),")?;
    writeln!(code, "        }};")?;
    writeln!(code)?;
    writeln!(code, "        // Set built-in defaults")?;
    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        writeln!(
            code,
            "        builder.defaults.{} = Some(toml::Value::from({:?}));",
            field_name, opt.default
        )?;
    }
    writeln!(code, "        builder")?;
    writeln!(code, "    }}")?;
    writeln!(code)?;

    // Add source methods
    writeln!(
        code,
        "    pub fn add_pkl_source(&mut self, config: &crate::config::Config, user_config: &crate::config::UserConfig) {{"
    )?;
    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        for pkl_path in opt.sources.pkl.as_vec() {
            // Parse the PKL path to extract the field access pattern
            if pkl_path.starts_with("defaults.") {
                let field = pkl_path.strip_prefix("defaults.").unwrap();
                writeln!(
                    code,
                    "        // Extract {} from user config defaults",
                    pkl_path
                )?;
                match opt.typ.as_str() {
                    "bool" => writeln!(
                        code,
                        "        if let Some(val) = user_config.defaults.{} {{ self.pkl.{} = Some(toml::Value::Boolean(val)); }}",
                        field, field_name
                    )?,
                    "int" => writeln!(
                        code,
                        "        if let Some(val) = user_config.defaults.{} {{ self.pkl.{} = Some(toml::Value::Integer(val as i64)); }}",
                        field, field_name
                    )?,
                    typ if typ.starts_with("list<") => writeln!(
                        code,
                        "        if let Some(ref val) = user_config.defaults.{} {{ self.pkl.{} = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }}",
                        field, field_name
                    )?,
                    _ => writeln!(
                        code,
                        "        // TODO: Handle type {} for {}",
                        opt.typ, pkl_path
                    )?,
                }
            } else {
                // Direct config field
                match opt.typ.as_str() {
                    "bool" => writeln!(
                        code,
                        "        if let Some(val) = config.{} {{ self.pkl.{} = Some(toml::Value::Boolean(val)); }}",
                        pkl_path, field_name
                    )?,
                    typ if typ.starts_with("list<") => writeln!(
                        code,
                        "        if let Some(ref val) = config.{} {{ self.pkl.{} = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }}",
                        pkl_path, field_name
                    )?,
                    _ => writeln!(
                        code,
                        "        // TODO: Handle type {} for {}",
                        opt.typ, pkl_path
                    )?,
                }
            }
        }
    }
    writeln!(code, "    }}")?;
    writeln!(code)?;

    writeln!(code, "    pub fn add_env_source(&mut self) {{")?;
    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        for env_var in &opt.sources.env {
            writeln!(
                code,
                "        if let Ok(val) = std::env::var(\"{}\") {{",
                env_var
            )?;
            match opt.typ.as_str() {
                "bool" => {
                    writeln!(code, "            let b = val == \"true\" || val == \"1\";")?;
                    writeln!(
                        code,
                        "            self.env.{} = Some(toml::Value::Boolean(b));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"env:{}\".to_string());",
                        field_name, env_var
                    )?;
                }
                "int" => {
                    writeln!(code, "            if let Ok(i) = val.parse::<i64>() {{")?;
                    writeln!(
                        code,
                        "                self.env.{} = Some(toml::Value::Integer(i));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "                self.sources.insert(\"{}\".to_string(), \"env:{}\".to_string());",
                        field_name, env_var
                    )?;
                    writeln!(code, "            }}")?;
                }
                typ if typ.starts_with("list<") => {
                    writeln!(
                        code,
                        "            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();"
                    )?;
                    writeln!(
                        code,
                        "            self.env.{} = Some(toml::Value::Array(items));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"env:{}\".to_string());",
                        field_name, env_var
                    )?;
                }
                _ => {
                    writeln!(
                        code,
                        "            self.env.{} = Some(toml::Value::String(val));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"env:{}\".to_string());",
                        field_name, env_var
                    )?;
                }
            }
            writeln!(code, "        }}")?;
        }
    }
    writeln!(code, "    }}")?;
    writeln!(code)?;

    writeln!(
        code,
        "    pub fn add_git_source(&mut self, config: &git2::Config) -> Result<(), git2::Error> {{"
    )?;
    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        for git_key in &opt.sources.git {
            match opt.typ.as_str() {
                "bool" => {
                    writeln!(
                        code,
                        "        if let Ok(val) = config.get_bool(\"{}\") {{",
                        git_key
                    )?;
                    writeln!(
                        code,
                        "            self.git.{} = Some(toml::Value::Boolean(val));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"git:{}\".to_string());",
                        field_name, git_key
                    )?;
                    writeln!(code, "        }}")?;
                }
                "int" => {
                    writeln!(
                        code,
                        "        if let Ok(val) = config.get_i32(\"{}\") {{",
                        git_key
                    )?;
                    writeln!(
                        code,
                        "            self.git.{} = Some(toml::Value::Integer(val as i64));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"git:{}\".to_string());",
                        field_name, git_key
                    )?;
                    writeln!(code, "        }}")?;
                }
                "string" | "path" | "enum" => {
                    writeln!(
                        code,
                        "        if let Ok(val) = config.get_string(\"{}\") {{",
                        git_key
                    )?;
                    writeln!(
                        code,
                        "            self.git.{} = Some(toml::Value::String(val));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"git:{}\".to_string());",
                        field_name, git_key
                    )?;
                    writeln!(code, "        }}")?;
                }
                typ if typ.starts_with("list<") => {
                    writeln!(
                        code,
                        "        if let Ok(vals) = read_string_list(config, \"{}\") {{",
                        git_key
                    )?;
                    writeln!(
                        code,
                        "            let array = vals.into_iter().map(toml::Value::String).collect();"
                    )?;
                    writeln!(
                        code,
                        "            self.git.{} = Some(toml::Value::Array(array));",
                        field_name
                    )?;
                    writeln!(
                        code,
                        "            self.sources.insert(\"{}\".to_string(), \"git:{}\".to_string());",
                        field_name, git_key
                    )?;
                    writeln!(code, "        }}")?;
                }
                _ => {}
            }
        }
    }
    writeln!(code, "        Ok(())")?;
    writeln!(code, "    }}")?;
    writeln!(code)?;

    // Build method with proper merge logic
    writeln!(
        code,
        "    pub fn build(self) -> (GeneratedSettings, SettingsSources) {{"
    )?;
    writeln!(code, "        let settings = GeneratedSettings {{")?;

    for (name, opt) in &registry.option {
        let field_name = name.replace('-', "_");
        writeln!(code, "            {}: {{", field_name)?;
        writeln!(
            code,
            "                // Precedence: CLI > env > git > PKL > defaults"
        )?;
        writeln!(code, "                // Merge policy: {}", opt.merge)?;

        if opt.merge == "union" {
            // Union merge for lists
            writeln!(code, "                let mut result = IndexSet::new();")?;
            writeln!(code, "                // Start with defaults")?;
            writeln!(
                code,
                "                if let Some(toml::Value::Array(arr)) = &self.defaults.{} {{",
                field_name
            )?;
            writeln!(code, "                    for val in arr {{")?;
            writeln!(
                code,
                "                        if let toml::Value::String(s) = val {{"
            )?;
            writeln!(
                code,
                "                            result.insert(s.clone());"
            )?;
            writeln!(code, "                        }}")?;
            writeln!(code, "                    }}")?;
            writeln!(code, "                }}")?;
            writeln!(code, "                // Add PKL values")?;
            writeln!(
                code,
                "                if let Some(toml::Value::Array(arr)) = &self.pkl.{} {{",
                field_name
            )?;
            writeln!(code, "                    for val in arr {{")?;
            writeln!(
                code,
                "                        if let toml::Value::String(s) = val {{"
            )?;
            writeln!(
                code,
                "                            result.insert(s.clone());"
            )?;
            writeln!(code, "                        }}")?;
            writeln!(code, "                    }}")?;
            writeln!(code, "                }}")?;
            writeln!(code, "                // Add git values")?;
            writeln!(
                code,
                "                if let Some(toml::Value::Array(arr)) = &self.git.{} {{",
                field_name
            )?;
            writeln!(code, "                    for val in arr {{")?;
            writeln!(
                code,
                "                        if let toml::Value::String(s) = val {{"
            )?;
            writeln!(
                code,
                "                            result.insert(s.clone());"
            )?;
            writeln!(code, "                        }}")?;
            writeln!(code, "                    }}")?;
            writeln!(code, "                }}")?;
            writeln!(code, "                // Add env values")?;
            writeln!(
                code,
                "                if let Some(toml::Value::Array(arr)) = &self.env.{} {{",
                field_name
            )?;
            writeln!(code, "                    for val in arr {{")?;
            writeln!(
                code,
                "                        if let toml::Value::String(s) = val {{"
            )?;
            writeln!(
                code,
                "                            result.insert(s.clone());"
            )?;
            writeln!(code, "                        }}")?;
            writeln!(code, "                    }}")?;
            writeln!(code, "                }}")?;
            writeln!(code, "                // Add CLI values")?;
            writeln!(
                code,
                "                if let Some(toml::Value::Array(arr)) = &self.cli.{} {{",
                field_name
            )?;
            writeln!(code, "                    for val in arr {{")?;
            writeln!(
                code,
                "                        if let toml::Value::String(s) = val {{"
            )?;
            writeln!(
                code,
                "                            result.insert(s.clone());"
            )?;
            writeln!(code, "                        }}")?;
            writeln!(code, "                    }}")?;
            writeln!(code, "                }}")?;
            if name == "display_skip_reasons" && opt.default == toml::Value::Array(vec![]) {
                // Special handling for display_skip_reasons default
                writeln!(code, "                if result.is_empty() {{")?;
                writeln!(
                    code,
                    "                    result.insert(\"profile-not-enabled\".to_string());"
                )?;
                writeln!(code, "                }}")?;
            }
            writeln!(code, "                result")?;
        } else {
            // Replace merge (last wins)
            writeln!(code, "                let val = self.cli.{}", field_name)?;
            writeln!(code, "                    .or(self.env.{})", field_name)?;
            writeln!(code, "                    .or(self.git.{})", field_name)?;
            writeln!(code, "                    .or(self.pkl.{})", field_name)?;
            writeln!(
                code,
                "                    .or(self.defaults.{});",
                field_name
            )?;

            // Convert toml::Value to the correct Rust type
            let conversion = match opt.typ.as_str() {
                "bool" => {
                    writeln!(
                        code,
                        "                val.and_then(|v| v.as_bool()).unwrap_or({})",
                        match opt.default {
                            toml::Value::Boolean(b) => b,
                            _ => false,
                        }
                    )?;
                }
                "int" => {
                    if name == "jobs" {
                        writeln!(code, "                val.and_then(|v| v.as_integer())")?;
                        writeln!(
                            code,
                            "                    .and_then(|i| NonZero::new(i as usize))"
                        )?;
                        writeln!(
                            code,
                            "                    .unwrap_or_else(|| NonZero::new(4).unwrap())"
                        )?;
                    } else if name == "verbose" {
                        writeln!(code, "                val.and_then(|v| v.as_integer())")?;
                        writeln!(
                            code,
                            "                    .and_then(|i| NonZero::new(i as usize))"
                        )?;
                        writeln!(
                            code,
                            "                    .unwrap_or_else(|| NonZero::new(1).unwrap())"
                        )?;
                    } else {
                        writeln!(
                            code,
                            "                val.and_then(|v| v.as_integer()).unwrap_or(0) as usize"
                        )?;
                    }
                }
                "string" | "enum" => {
                    let default = match &opt.default {
                        toml::Value::String(s) => format!("\"{}\"", s),
                        _ => "\"\"".to_string(),
                    };
                    writeln!(
                        code,
                        "                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| {}.to_string())",
                        default
                    )?;
                }
                "path" => {
                    let default = match &opt.default {
                        toml::Value::String(s) if !s.is_empty() => format!("\"{}\"", s),
                        _ => "\"\"".to_string(),
                    };
                    writeln!(
                        code,
                        "                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from({}))",
                        default
                    )?;
                }
                typ if typ.starts_with("list<") => {
                    writeln!(code, "                val.and_then(|v| v.as_array())")?;
                    writeln!(code, "                    .map(|arr| arr.iter()")?;
                    writeln!(
                        code,
                        "                        .filter_map(|v| v.as_str().map(|s| s.to_string()))"
                    )?;
                    writeln!(code, "                        .collect())")?;
                    writeln!(code, "                    .unwrap_or_else(IndexSet::new)")?;
                }
                _ => writeln!(code, "                Default::default()")?,
            };
        }

        writeln!(code, "            }},")?;
    }

    writeln!(code, "        }};")?;
    writeln!(code)?;
    writeln!(code, "        let sources = SettingsSources {{")?;
    writeln!(code, "            sources: self.sources,")?;
    writeln!(code, "        }};")?;
    writeln!(code)?;
    writeln!(code, "        (settings, sources)")?;
    writeln!(code, "    }}")?;
    writeln!(code, "}}")?;
    writeln!(code)?;

    // Helper function for git config
    writeln!(
        code,
        "fn read_string_list(config: &git2::Config, key: &str) -> Result<IndexSet<String>, git2::Error> {{"
    )?;
    writeln!(code, "    let mut result = IndexSet::new();")?;
    writeln!(code, "    match config.multivar(key, None) {{")?;
    writeln!(code, "        Ok(mut entries) => {{")?;
    writeln!(
        code,
        "            while let Some(entry) = entries.next() {{"
    )?;
    writeln!(
        code,
        "                if let Some(value) = entry?.value() {{"
    )?;
    writeln!(
        code,
        "                    for item in value.split(',').map(|s| s.trim()) {{"
    )?;
    writeln!(code, "                        if !item.is_empty() {{")?;
    writeln!(
        code,
        "                            result.insert(item.to_string());"
    )?;
    writeln!(code, "                        }}")?;
    writeln!(code, "                    }}")?;
    writeln!(code, "                }}")?;
    writeln!(code, "            }}")?;
    writeln!(code, "        }}")?;
    writeln!(code, "        Err(_) => {{")?;
    writeln!(
        code,
        "            if let Ok(value) = config.get_string(key) {{"
    )?;
    writeln!(
        code,
        "                for item in value.split(',').map(|s| s.trim()) {{"
    )?;
    writeln!(code, "                    if !item.is_empty() {{")?;
    writeln!(
        code,
        "                        result.insert(item.to_string());"
    )?;
    writeln!(code, "                    }}")?;
    writeln!(code, "                }}")?;
    writeln!(code, "            }}")?;
    writeln!(code, "        }}")?;
    writeln!(code, "    }}")?;
    writeln!(code, "    Ok(result)")?;
    writeln!(code, "}}")?;

    fs::write(gen_dir.join("settings.rs"), code)?;
    Ok(())
}

fn generate_cli_flags(
    registry: &SettingsRegistry,
    gen_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();

    writeln!(code, "// THIS FILE IS AUTO-GENERATED - DO NOT EDIT")?;
    writeln!(code, "// Generated by build.rs from settings.toml")?;
    writeln!(code)?;
    writeln!(code, "#![allow(dead_code)]")?;
    writeln!(code)?;
    writeln!(code, "use clap::Args;")?;
    writeln!(code, "use std::num::NonZero;")?;
    writeln!(code, "use std::path::PathBuf;")?;
    writeln!(code)?;

    writeln!(code, "#[derive(Debug, Args, Default)]")?;
    writeln!(code, "pub struct GeneratedCliFlags {{")?;

    for (name, opt) in &registry.option {
        if opt.sources.cli.is_empty() {
            continue;
        }

        let field_name = name.replace('-', "_");
        let field_type = clap_type(&opt.typ);

        writeln!(code, "    /// {}", opt.docs)?;

        let mut attrs = Vec::new();
        for cli_flag in &opt.sources.cli {
            if cli_flag.starts_with("--") {
                let flag = cli_flag.trim_start_matches("--");
                if flag == name {
                    attrs.push("long".to_string());
                } else {
                    attrs.push(format!("long = \"{}\"", flag));
                }
            } else if cli_flag.starts_with("-") && cli_flag.len() == 2 {
                let flag = cli_flag.trim_start_matches("-");
                attrs.push(format!("short = '{}'", flag.chars().next().unwrap()));
            }
        }

        // Handle special cases for flags
        if name == "verbose" {
            attrs.push("action = clap::ArgAction::Count".to_string());
        }

        if !attrs.is_empty() {
            writeln!(code, "    #[clap({})]", attrs.join(", "))?;
        }

        if name == "verbose" {
            writeln!(code, "    pub {}: u8,", field_name)?;
        } else {
            writeln!(code, "    pub {}: Option<{}>,", field_name, field_type)?;
        }
    }

    writeln!(code, "}}")?;

    fs::write(gen_dir.join("cli_flags.rs"), code)?;
    Ok(())
}

fn generate_git_config(
    registry: &SettingsRegistry,
    gen_dir: &Path,
) -> Result<(), Box<dyn std::error::Error>> {
    let mut code = String::new();

    writeln!(code, "// THIS FILE IS AUTO-GENERATED - DO NOT EDIT")?;
    writeln!(code, "// Generated by build.rs from settings.toml")?;
    writeln!(code)?;
    writeln!(code, "#![allow(dead_code)]")?;
    writeln!(code)?;

    writeln!(code, "pub struct GitConfigKeys {{")?;

    for (name, opt) in &registry.option {
        if opt.sources.git.is_empty() {
            continue;
        }

        let field_name = name.replace('-', "_");
        writeln!(code, "    pub {}: Vec<&'static str>,", field_name)?;
    }

    writeln!(code, "}}")?;
    writeln!(code)?;

    writeln!(
        code,
        "pub const GIT_CONFIG_KEYS: GitConfigKeys = GitConfigKeys {{"
    )?;

    for (name, opt) in &registry.option {
        if opt.sources.git.is_empty() {
            continue;
        }

        let field_name = name.replace('-', "_");
        let keys = opt
            .sources
            .git
            .iter()
            .map(|k| format!("\"{}\"", k))
            .collect::<Vec<_>>()
            .join(", ");
        writeln!(code, "    {}: vec![{}],", field_name, keys)?;
    }

    writeln!(code, "}};")?;

    fs::write(gen_dir.join("git_keys.rs"), code)?;
    Ok(())
}

fn generate_docs(registry: &SettingsRegistry) -> Result<(), Box<dyn std::error::Error>> {
    let mut doc = String::new();

    writeln!(doc, "# HK Configuration Reference")?;
    writeln!(doc)?;
    writeln!(doc, "This document is auto-generated from `settings.toml`.")?;
    writeln!(doc)?;

    for (name, opt) in &registry.option {
        writeln!(doc, "## `{}`", name)?;
        writeln!(doc)?;
        writeln!(doc, "{}", opt.docs)?;
        writeln!(doc)?;
        writeln!(doc, "- **Type**: `{}`", opt.typ)?;
        writeln!(doc, "- **Default**: `{:?}`", opt.default)?;
        writeln!(doc, "- **Merge Policy**: `{}`", opt.merge)?;
        writeln!(doc)?;

        if !opt.sources.pkl.as_vec().is_empty() {
            writeln!(doc, "### PKL Sources")?;
            for src in opt.sources.pkl.as_vec() {
                writeln!(doc, "- `{}`", src)?;
            }
            writeln!(doc)?;
        }

        if !opt.sources.env.is_empty() {
            writeln!(doc, "### Environment Variables")?;
            for src in &opt.sources.env {
                writeln!(doc, "- `{}`", src)?;
            }
            writeln!(doc)?;
        }

        if !opt.sources.git.is_empty() {
            writeln!(doc, "### Git Config Keys")?;
            for src in &opt.sources.git {
                writeln!(doc, "- `{}`", src)?;
            }
            writeln!(doc)?;
        }

        if !opt.sources.cli.is_empty() {
            writeln!(doc, "### CLI Flags")?;
            for src in &opt.sources.cli {
                writeln!(doc, "- `{}`", src)?;
            }
            writeln!(doc)?;
        }

        if !opt.validate.enum_values.is_empty() {
            writeln!(doc, "### Valid Values")?;
            for val in &opt.validate.enum_values {
                writeln!(doc, "- `{}`", val)?;
            }
            writeln!(doc)?;
        }
    }

    fs::create_dir_all("docs")?;
    fs::write("docs/config_reference.md", doc)?;
    Ok(())
}

fn rust_type(typ: &str, name: &str) -> String {
    match typ {
        "bool" => "bool".to_string(),
        "int" => {
            if name == "jobs" || name == "verbose" {
                "NonZero<usize>".to_string()
            } else {
                "usize".to_string()
            }
        }
        "string" => "String".to_string(),
        "path" => "PathBuf".to_string(),
        "enum" => "String".to_string(),
        typ if typ.starts_with("list<string>") => "IndexSet<String>".to_string(),
        _ => "String".to_string(),
    }
}

fn clap_type(typ: &str) -> String {
    match typ {
        "bool" => "bool".to_string(),
        "int" => "usize".to_string(),
        "string" => "String".to_string(),
        "path" => "PathBuf".to_string(),
        "enum" => "String".to_string(),
        typ if typ.starts_with("list<") => "Vec<String>".to_string(),
        _ => "String".to_string(),
    }
}
