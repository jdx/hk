// THIS FILE IS AUTO-GENERATED - DO NOT EDIT
// Generated by build.rs from settings.toml

#![allow(dead_code)]
#![allow(unused_imports)]

use indexmap::IndexSet;
use std::collections::HashMap;
use std::num::NonZero;
use std::path::PathBuf;

#[derive(Debug, Clone)]
pub struct GeneratedSettings {
    /// Run on all files instead of just staged files.
    pub all: bool,
    /// Directory for cache files.
    pub cache_dir: PathBuf,
    /// Run check command instead of fix command.
    pub check: bool,
    /// Run check before fix.
    pub check_first: bool,
    /// Which skip reasons to display. Options: all, none, disabled-by-config, profile-not-enabled.
    pub display_skip_reasons: IndexSet<String>,
    /// Glob patterns to exclude from processing (union across sources).
    pub exclude: IndexSet<String>,
    /// Abort execution on first failure.
    pub fail_fast: bool,
    /// Default configuration file name.
    pub file: String,
    /// Specific files to run on.
    pub files: IndexSet<String>,
    /// Run fix command instead of check command.
    pub fix: bool,
    /// Start reference for checking files.
    pub from_ref: String,
    /// Run on files that match these glob patterns.
    pub glob: IndexSet<String>,
    /// Warning tags to hide (union across sources).
    pub hide_warnings: IndexSet<String>,
    /// Hide output after successful completion.
    pub hide_when_done: bool,
    /// Path to user configuration file.
    pub hkrc: PathBuf,
    /// Maximum number of parallel jobs to run. 0 means auto-detect.
    pub jobs: NonZero<usize>,
    /// Output in JSON format.
    pub json: bool,
    /// Use libgit2 instead of git CLI commands.
    pub libgit2: bool,
    /// Path to log file.
    pub log_file: PathBuf,
    /// Log level for file output.
    pub log_file_level: String,
    /// Log level for console output.
    pub log_level: String,
    /// Enable mise integration.
    pub mise: bool,
    /// Disable progress output.
    pub no_progress: bool,
    /// Print the plan instead of executing.
    pub plan: bool,
    /// Profiles to enable/disable. Prefix with '!' to disable.
    pub profiles: IndexSet<String>,
    /// Suppress output.
    pub quiet: bool,
    /// Suppress all output.
    pub silent: bool,
    /// Skip entire hooks (union across sources).
    pub skip_hooks: IndexSet<String>,
    /// Skip specific steps across all hooks (union across sources).
    pub skip_steps: IndexSet<String>,
    /// Enable slow mode. Shorthand for --profile=slow.
    pub slow: bool,
    /// Stash method to use for git hooks.
    pub stash: String,
    /// Include untracked files when stashing.
    pub stash_untracked: bool,
    /// Directory for state files.
    pub state_dir: PathBuf,
    /// Run only specific step(s).
    pub step: IndexSet<String>,
    /// Allow output summaries to be printed in text mode.
    pub summary_text: bool,
    /// Path to write JSON timing report after hook finishes.
    pub timing_json: PathBuf,
    /// End reference for checking files.
    pub to_ref: String,
    /// Enable tracing spans and performance diagnostics.
    pub trace: String,
    /// Verbose output level.
    pub verbose: NonZero<usize>,
    /// Warning tags to enable/show.
    pub warnings: IndexSet<String>,
}

#[derive(Debug, Clone)]
pub struct SettingsSources {
    /// Map of field name to source description
    pub sources: HashMap<String, String>,
}

pub struct SettingsBuilder {
    // Store values by precedence layer
    defaults: LayerValues,
    pkl: LayerValues,
    git: LayerValues,
    env: LayerValues,
    cli: LayerValues,
    sources: HashMap<String, String>,
}

#[derive(Default)]
struct LayerValues {
    all: Option<toml::Value>,
    cache_dir: Option<toml::Value>,
    check: Option<toml::Value>,
    check_first: Option<toml::Value>,
    display_skip_reasons: Option<toml::Value>,
    exclude: Option<toml::Value>,
    fail_fast: Option<toml::Value>,
    file: Option<toml::Value>,
    files: Option<toml::Value>,
    fix: Option<toml::Value>,
    from_ref: Option<toml::Value>,
    glob: Option<toml::Value>,
    hide_warnings: Option<toml::Value>,
    hide_when_done: Option<toml::Value>,
    hkrc: Option<toml::Value>,
    jobs: Option<toml::Value>,
    json: Option<toml::Value>,
    libgit2: Option<toml::Value>,
    log_file: Option<toml::Value>,
    log_file_level: Option<toml::Value>,
    log_level: Option<toml::Value>,
    mise: Option<toml::Value>,
    no_progress: Option<toml::Value>,
    plan: Option<toml::Value>,
    profiles: Option<toml::Value>,
    quiet: Option<toml::Value>,
    silent: Option<toml::Value>,
    skip_hooks: Option<toml::Value>,
    skip_steps: Option<toml::Value>,
    slow: Option<toml::Value>,
    stash: Option<toml::Value>,
    stash_untracked: Option<toml::Value>,
    state_dir: Option<toml::Value>,
    step: Option<toml::Value>,
    summary_text: Option<toml::Value>,
    timing_json: Option<toml::Value>,
    to_ref: Option<toml::Value>,
    trace: Option<toml::Value>,
    verbose: Option<toml::Value>,
    warnings: Option<toml::Value>,
}

impl SettingsBuilder {
    pub fn new() -> Self {
        let mut builder = Self {
            defaults: LayerValues::default(),
            pkl: LayerValues::default(),
            git: LayerValues::default(),
            env: LayerValues::default(),
            cli: LayerValues::default(),
            sources: HashMap::new(),
        };

        // Set built-in defaults
        builder.defaults.all = Some(toml::Value::from(Boolean(false)));
        builder.defaults.cache_dir = Some(toml::Value::from(String("")));
        builder.defaults.check = Some(toml::Value::from(Boolean(false)));
        builder.defaults.check_first = Some(toml::Value::from(Boolean(true)));
        builder.defaults.display_skip_reasons = Some(toml::Value::from(Array([String("profile-not-enabled")])));
        builder.defaults.exclude = Some(toml::Value::from(Array([])));
        builder.defaults.fail_fast = Some(toml::Value::from(Boolean(true)));
        builder.defaults.file = Some(toml::Value::from(String("hk.pkl")));
        builder.defaults.files = Some(toml::Value::from(Array([])));
        builder.defaults.fix = Some(toml::Value::from(Boolean(true)));
        builder.defaults.from_ref = Some(toml::Value::from(String("")));
        builder.defaults.glob = Some(toml::Value::from(Array([])));
        builder.defaults.hide_warnings = Some(toml::Value::from(Array([])));
        builder.defaults.hide_when_done = Some(toml::Value::from(Boolean(false)));
        builder.defaults.hkrc = Some(toml::Value::from(String(".hkrc.pkl")));
        builder.defaults.jobs = Some(toml::Value::from(Integer(0)));
        builder.defaults.json = Some(toml::Value::from(Boolean(false)));
        builder.defaults.libgit2 = Some(toml::Value::from(Boolean(true)));
        builder.defaults.log_file = Some(toml::Value::from(String("")));
        builder.defaults.log_file_level = Some(toml::Value::from(String("info")));
        builder.defaults.log_level = Some(toml::Value::from(String("info")));
        builder.defaults.mise = Some(toml::Value::from(Boolean(false)));
        builder.defaults.no_progress = Some(toml::Value::from(Boolean(false)));
        builder.defaults.plan = Some(toml::Value::from(Boolean(false)));
        builder.defaults.profiles = Some(toml::Value::from(Array([])));
        builder.defaults.quiet = Some(toml::Value::from(Boolean(false)));
        builder.defaults.silent = Some(toml::Value::from(Boolean(false)));
        builder.defaults.skip_hooks = Some(toml::Value::from(Array([])));
        builder.defaults.skip_steps = Some(toml::Value::from(Array([])));
        builder.defaults.slow = Some(toml::Value::from(Boolean(false)));
        builder.defaults.stash = Some(toml::Value::from(String("auto")));
        builder.defaults.stash_untracked = Some(toml::Value::from(Boolean(true)));
        builder.defaults.state_dir = Some(toml::Value::from(String("")));
        builder.defaults.step = Some(toml::Value::from(Array([])));
        builder.defaults.summary_text = Some(toml::Value::from(Boolean(false)));
        builder.defaults.timing_json = Some(toml::Value::from(String("")));
        builder.defaults.to_ref = Some(toml::Value::from(String("")));
        builder.defaults.trace = Some(toml::Value::from(String("off")));
        builder.defaults.verbose = Some(toml::Value::from(Integer(0)));
        builder.defaults.warnings = Some(toml::Value::from(Array([])));
        builder
    }

    pub fn add_pkl_source(&mut self, config: &crate::config::Config, user_config: &crate::config::UserConfig) {
        if let Some(ref val) = config.display_skip_reasons { self.pkl.display_skip_reasons = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        // Extract defaults.exclude from user config defaults
        if let Some(ref val) = user_config.defaults.exclude { self.pkl.exclude = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        if let Some(val) = config.fail_fast { self.pkl.fail_fast = Some(toml::Value::Boolean(val)); }
        // Extract defaults.fail_fast from user config defaults
        if let Some(val) = user_config.defaults.fail_fast { self.pkl.fail_fast = Some(toml::Value::Boolean(val)); }
        if let Some(ref val) = config.hide_warnings { self.pkl.hide_warnings = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        // Extract defaults.jobs from user config defaults
        if let Some(val) = user_config.defaults.jobs { self.pkl.jobs = Some(toml::Value::Integer(val as i64)); }
        // Extract defaults.profiles from user config defaults
        if let Some(ref val) = user_config.defaults.profiles { self.pkl.profiles = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        // Extract defaults.skip_hooks from user config defaults
        if let Some(ref val) = user_config.defaults.skip_hooks { self.pkl.skip_hooks = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        // Extract defaults.skip_steps from user config defaults
        if let Some(ref val) = user_config.defaults.skip_steps { self.pkl.skip_steps = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
        if let Some(ref val) = config.warnings { self.pkl.warnings = Some(toml::Value::Array(val.iter().map(|s| toml::Value::String(s.clone())).collect())); }
    }

    pub fn add_env_source(&mut self) {
        if let Ok(val) = std::env::var("HK_CACHE_DIR") {
            self.env.cache_dir = Some(toml::Value::String(val));
            self.sources.insert("cache_dir".to_string(), "env:HK_CACHE_DIR".to_string());
        }
        if let Ok(val) = std::env::var("HK_CHECK") {
            let b = val == "true" || val == "1";
            self.env.check = Some(toml::Value::Boolean(b));
            self.sources.insert("check".to_string(), "env:HK_CHECK".to_string());
        }
        if let Ok(val) = std::env::var("HK_CHECK_FIRST") {
            let b = val == "true" || val == "1";
            self.env.check_first = Some(toml::Value::Boolean(b));
            self.sources.insert("check_first".to_string(), "env:HK_CHECK_FIRST".to_string());
        }
        if let Ok(val) = std::env::var("HK_DISPLAY_SKIP_REASONS") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.display_skip_reasons = Some(toml::Value::Array(items));
            self.sources.insert("display_skip_reasons".to_string(), "env:HK_DISPLAY_SKIP_REASONS".to_string());
        }
        if let Ok(val) = std::env::var("HK_EXCLUDE") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.exclude = Some(toml::Value::Array(items));
            self.sources.insert("exclude".to_string(), "env:HK_EXCLUDE".to_string());
        }
        if let Ok(val) = std::env::var("HK_FAIL_FAST") {
            let b = val == "true" || val == "1";
            self.env.fail_fast = Some(toml::Value::Boolean(b));
            self.sources.insert("fail_fast".to_string(), "env:HK_FAIL_FAST".to_string());
        }
        if let Ok(val) = std::env::var("HK_FILE") {
            self.env.file = Some(toml::Value::String(val));
            self.sources.insert("file".to_string(), "env:HK_FILE".to_string());
        }
        if let Ok(val) = std::env::var("HK_FIX") {
            let b = val == "true" || val == "1";
            self.env.fix = Some(toml::Value::Boolean(b));
            self.sources.insert("fix".to_string(), "env:HK_FIX".to_string());
        }
        if let Ok(val) = std::env::var("HK_HIDE_WARNINGS") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.hide_warnings = Some(toml::Value::Array(items));
            self.sources.insert("hide_warnings".to_string(), "env:HK_HIDE_WARNINGS".to_string());
        }
        if let Ok(val) = std::env::var("HK_HIDE_WHEN_DONE") {
            let b = val == "true" || val == "1";
            self.env.hide_when_done = Some(toml::Value::Boolean(b));
            self.sources.insert("hide_when_done".to_string(), "env:HK_HIDE_WHEN_DONE".to_string());
        }
        if let Ok(val) = std::env::var("HK_JOBS") {
            if let Ok(i) = val.parse::<i64>() {
                self.env.jobs = Some(toml::Value::Integer(i));
                self.sources.insert("jobs".to_string(), "env:HK_JOBS".to_string());
            }
        }
        if let Ok(val) = std::env::var("HK_JOB") {
            if let Ok(i) = val.parse::<i64>() {
                self.env.jobs = Some(toml::Value::Integer(i));
                self.sources.insert("jobs".to_string(), "env:HK_JOB".to_string());
            }
        }
        if let Ok(val) = std::env::var("HK_JSON") {
            let b = val == "true" || val == "1";
            self.env.json = Some(toml::Value::Boolean(b));
            self.sources.insert("json".to_string(), "env:HK_JSON".to_string());
        }
        if let Ok(val) = std::env::var("HK_LIBGIT2") {
            let b = val == "true" || val == "1";
            self.env.libgit2 = Some(toml::Value::Boolean(b));
            self.sources.insert("libgit2".to_string(), "env:HK_LIBGIT2".to_string());
        }
        if let Ok(val) = std::env::var("HK_LOG_FILE") {
            self.env.log_file = Some(toml::Value::String(val));
            self.sources.insert("log_file".to_string(), "env:HK_LOG_FILE".to_string());
        }
        if let Ok(val) = std::env::var("HK_LOG_FILE_LEVEL") {
            self.env.log_file_level = Some(toml::Value::String(val));
            self.sources.insert("log_file_level".to_string(), "env:HK_LOG_FILE_LEVEL".to_string());
        }
        if let Ok(val) = std::env::var("HK_LOG") {
            self.env.log_level = Some(toml::Value::String(val));
            self.sources.insert("log_level".to_string(), "env:HK_LOG".to_string());
        }
        if let Ok(val) = std::env::var("HK_LOG_LEVEL") {
            self.env.log_level = Some(toml::Value::String(val));
            self.sources.insert("log_level".to_string(), "env:HK_LOG_LEVEL".to_string());
        }
        if let Ok(val) = std::env::var("HK_MISE") {
            let b = val == "true" || val == "1";
            self.env.mise = Some(toml::Value::Boolean(b));
            self.sources.insert("mise".to_string(), "env:HK_MISE".to_string());
        }
        if let Ok(val) = std::env::var("HK_PROFILE") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.profiles = Some(toml::Value::Array(items));
            self.sources.insert("profiles".to_string(), "env:HK_PROFILE".to_string());
        }
        if let Ok(val) = std::env::var("HK_PROFILES") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.profiles = Some(toml::Value::Array(items));
            self.sources.insert("profiles".to_string(), "env:HK_PROFILES".to_string());
        }
        if let Ok(val) = std::env::var("HK_SKIP_HOOK") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.skip_hooks = Some(toml::Value::Array(items));
            self.sources.insert("skip_hooks".to_string(), "env:HK_SKIP_HOOK".to_string());
        }
        if let Ok(val) = std::env::var("HK_SKIP_HOOKS") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.skip_hooks = Some(toml::Value::Array(items));
            self.sources.insert("skip_hooks".to_string(), "env:HK_SKIP_HOOKS".to_string());
        }
        if let Ok(val) = std::env::var("HK_SKIP_STEPS") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.skip_steps = Some(toml::Value::Array(items));
            self.sources.insert("skip_steps".to_string(), "env:HK_SKIP_STEPS".to_string());
        }
        if let Ok(val) = std::env::var("HK_SKIP_STEP") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.skip_steps = Some(toml::Value::Array(items));
            self.sources.insert("skip_steps".to_string(), "env:HK_SKIP_STEP".to_string());
        }
        if let Ok(val) = std::env::var("HK_STASH") {
            self.env.stash = Some(toml::Value::String(val));
            self.sources.insert("stash".to_string(), "env:HK_STASH".to_string());
        }
        if let Ok(val) = std::env::var("HK_STASH_UNTRACKED") {
            let b = val == "true" || val == "1";
            self.env.stash_untracked = Some(toml::Value::Boolean(b));
            self.sources.insert("stash_untracked".to_string(), "env:HK_STASH_UNTRACKED".to_string());
        }
        if let Ok(val) = std::env::var("HK_STATE_DIR") {
            self.env.state_dir = Some(toml::Value::String(val));
            self.sources.insert("state_dir".to_string(), "env:HK_STATE_DIR".to_string());
        }
        if let Ok(val) = std::env::var("HK_SUMMARY_TEXT") {
            let b = val == "true" || val == "1";
            self.env.summary_text = Some(toml::Value::Boolean(b));
            self.sources.insert("summary_text".to_string(), "env:HK_SUMMARY_TEXT".to_string());
        }
        if let Ok(val) = std::env::var("HK_TIMING_JSON") {
            self.env.timing_json = Some(toml::Value::String(val));
            self.sources.insert("timing_json".to_string(), "env:HK_TIMING_JSON".to_string());
        }
        if let Ok(val) = std::env::var("HK_TRACE") {
            self.env.trace = Some(toml::Value::String(val));
            self.sources.insert("trace".to_string(), "env:HK_TRACE".to_string());
        }
        if let Ok(val) = std::env::var("HK_WARNINGS") {
            let items: Vec<toml::Value> = val.split(',').map(|s| toml::Value::String(s.trim().to_string())).collect();
            self.env.warnings = Some(toml::Value::Array(items));
            self.sources.insert("warnings".to_string(), "env:HK_WARNINGS".to_string());
        }
    }

    pub fn add_git_source(&mut self, config: &git2::Config) -> Result<(), git2::Error> {
        if let Ok(val) = config.get_bool("hk.check") {
            self.git.check = Some(toml::Value::Boolean(val));
            self.sources.insert("check".to_string(), "git:hk.check".to_string());
        }
        if let Ok(val) = config.get_bool("hk.checkFirst") {
            self.git.check_first = Some(toml::Value::Boolean(val));
            self.sources.insert("check_first".to_string(), "git:hk.checkFirst".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.displaySkipReasons") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.display_skip_reasons = Some(toml::Value::Array(array));
            self.sources.insert("display_skip_reasons".to_string(), "git:hk.displaySkipReasons".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.exclude") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.exclude = Some(toml::Value::Array(array));
            self.sources.insert("exclude".to_string(), "git:hk.exclude".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.excludeGlob") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.exclude = Some(toml::Value::Array(array));
            self.sources.insert("exclude".to_string(), "git:hk.excludeGlob".to_string());
        }
        if let Ok(val) = config.get_bool("hk.failFast") {
            self.git.fail_fast = Some(toml::Value::Boolean(val));
            self.sources.insert("fail_fast".to_string(), "git:hk.failFast".to_string());
        }
        if let Ok(val) = config.get_bool("hk.fix") {
            self.git.fix = Some(toml::Value::Boolean(val));
            self.sources.insert("fix".to_string(), "git:hk.fix".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.hideWarnings") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.hide_warnings = Some(toml::Value::Array(array));
            self.sources.insert("hide_warnings".to_string(), "git:hk.hideWarnings".to_string());
        }
        if let Ok(val) = config.get_i32("hk.jobs") {
            self.git.jobs = Some(toml::Value::Integer(val as i64));
            self.sources.insert("jobs".to_string(), "git:hk.jobs".to_string());
        }
        if let Ok(val) = config.get_bool("hk.json") {
            self.git.json = Some(toml::Value::Boolean(val));
            self.sources.insert("json".to_string(), "git:hk.json".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.profile") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.profiles = Some(toml::Value::Array(array));
            self.sources.insert("profiles".to_string(), "git:hk.profile".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.skipHooks") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.skip_hooks = Some(toml::Value::Array(array));
            self.sources.insert("skip_hooks".to_string(), "git:hk.skipHooks".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.skipHook") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.skip_hooks = Some(toml::Value::Array(array));
            self.sources.insert("skip_hooks".to_string(), "git:hk.skipHook".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.skipSteps") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.skip_steps = Some(toml::Value::Array(array));
            self.sources.insert("skip_steps".to_string(), "git:hk.skipSteps".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.skipStep") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.skip_steps = Some(toml::Value::Array(array));
            self.sources.insert("skip_steps".to_string(), "git:hk.skipStep".to_string());
        }
        if let Ok(val) = config.get_string("hk.stash") {
            self.git.stash = Some(toml::Value::String(val));
            self.sources.insert("stash".to_string(), "git:hk.stash".to_string());
        }
        if let Ok(val) = config.get_bool("hk.stashUntracked") {
            self.git.stash_untracked = Some(toml::Value::Boolean(val));
            self.sources.insert("stash_untracked".to_string(), "git:hk.stashUntracked".to_string());
        }
        if let Ok(val) = config.get_string("hk.trace") {
            self.git.trace = Some(toml::Value::String(val));
            self.sources.insert("trace".to_string(), "git:hk.trace".to_string());
        }
        if let Ok(vals) = read_string_list(config, "hk.warnings") {
            let array = vals.into_iter().map(toml::Value::String).collect();
            self.git.warnings = Some(toml::Value::Array(array));
            self.sources.insert("warnings".to_string(), "git:hk.warnings".to_string());
        }
        Ok(())
    }

    pub fn build(self) -> (GeneratedSettings, SettingsSources) {
        let settings = GeneratedSettings {
            all: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.all
                    .or(self.env.all)
                    .or(self.git.all)
                    .or(self.pkl.all)
                    .or(self.defaults.all);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            cache_dir: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.cache_dir
                    .or(self.env.cache_dir)
                    .or(self.git.cache_dir)
                    .or(self.pkl.cache_dir)
                    .or(self.defaults.cache_dir);
                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from(""))
            },
            check: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.check
                    .or(self.env.check)
                    .or(self.git.check)
                    .or(self.pkl.check)
                    .or(self.defaults.check);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            check_first: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.check_first
                    .or(self.env.check_first)
                    .or(self.git.check_first)
                    .or(self.pkl.check_first)
                    .or(self.defaults.check_first);
                val.and_then(|v| v.as_bool()).unwrap_or(true)
            },
            display_skip_reasons: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.display_skip_reasons
                    .or(self.env.display_skip_reasons)
                    .or(self.git.display_skip_reasons)
                    .or(self.pkl.display_skip_reasons)
                    .or(self.defaults.display_skip_reasons);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
            exclude: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: union
                let mut result = IndexSet::new();
                // Start with defaults
                if let Some(toml::Value::Array(arr)) = &self.defaults.exclude {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add PKL values
                if let Some(toml::Value::Array(arr)) = &self.pkl.exclude {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add git values
                if let Some(toml::Value::Array(arr)) = &self.git.exclude {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add env values
                if let Some(toml::Value::Array(arr)) = &self.env.exclude {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add CLI values
                if let Some(toml::Value::Array(arr)) = &self.cli.exclude {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                result
            },
            fail_fast: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.fail_fast
                    .or(self.env.fail_fast)
                    .or(self.git.fail_fast)
                    .or(self.pkl.fail_fast)
                    .or(self.defaults.fail_fast);
                val.and_then(|v| v.as_bool()).unwrap_or(true)
            },
            file: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.file
                    .or(self.env.file)
                    .or(self.git.file)
                    .or(self.pkl.file)
                    .or(self.defaults.file);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "hk.pkl".to_string())
            },
            files: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.files
                    .or(self.env.files)
                    .or(self.git.files)
                    .or(self.pkl.files)
                    .or(self.defaults.files);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
            fix: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.fix
                    .or(self.env.fix)
                    .or(self.git.fix)
                    .or(self.pkl.fix)
                    .or(self.defaults.fix);
                val.and_then(|v| v.as_bool()).unwrap_or(true)
            },
            from_ref: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.from_ref
                    .or(self.env.from_ref)
                    .or(self.git.from_ref)
                    .or(self.pkl.from_ref)
                    .or(self.defaults.from_ref);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "".to_string())
            },
            glob: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.glob
                    .or(self.env.glob)
                    .or(self.git.glob)
                    .or(self.pkl.glob)
                    .or(self.defaults.glob);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
            hide_warnings: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: union
                let mut result = IndexSet::new();
                // Start with defaults
                if let Some(toml::Value::Array(arr)) = &self.defaults.hide_warnings {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add PKL values
                if let Some(toml::Value::Array(arr)) = &self.pkl.hide_warnings {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add git values
                if let Some(toml::Value::Array(arr)) = &self.git.hide_warnings {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add env values
                if let Some(toml::Value::Array(arr)) = &self.env.hide_warnings {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add CLI values
                if let Some(toml::Value::Array(arr)) = &self.cli.hide_warnings {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                result
            },
            hide_when_done: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.hide_when_done
                    .or(self.env.hide_when_done)
                    .or(self.git.hide_when_done)
                    .or(self.pkl.hide_when_done)
                    .or(self.defaults.hide_when_done);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            hkrc: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.hkrc
                    .or(self.env.hkrc)
                    .or(self.git.hkrc)
                    .or(self.pkl.hkrc)
                    .or(self.defaults.hkrc);
                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from(".hkrc.pkl"))
            },
            jobs: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.jobs
                    .or(self.env.jobs)
                    .or(self.git.jobs)
                    .or(self.pkl.jobs)
                    .or(self.defaults.jobs);
                val.and_then(|v| v.as_integer())
                    .and_then(|i| NonZero::new(i as usize))
                    .unwrap_or_else(|| NonZero::new(4).unwrap())
            },
            json: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.json
                    .or(self.env.json)
                    .or(self.git.json)
                    .or(self.pkl.json)
                    .or(self.defaults.json);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            libgit2: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.libgit2
                    .or(self.env.libgit2)
                    .or(self.git.libgit2)
                    .or(self.pkl.libgit2)
                    .or(self.defaults.libgit2);
                val.and_then(|v| v.as_bool()).unwrap_or(true)
            },
            log_file: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.log_file
                    .or(self.env.log_file)
                    .or(self.git.log_file)
                    .or(self.pkl.log_file)
                    .or(self.defaults.log_file);
                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from(""))
            },
            log_file_level: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.log_file_level
                    .or(self.env.log_file_level)
                    .or(self.git.log_file_level)
                    .or(self.pkl.log_file_level)
                    .or(self.defaults.log_file_level);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "info".to_string())
            },
            log_level: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.log_level
                    .or(self.env.log_level)
                    .or(self.git.log_level)
                    .or(self.pkl.log_level)
                    .or(self.defaults.log_level);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "info".to_string())
            },
            mise: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.mise
                    .or(self.env.mise)
                    .or(self.git.mise)
                    .or(self.pkl.mise)
                    .or(self.defaults.mise);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            no_progress: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.no_progress
                    .or(self.env.no_progress)
                    .or(self.git.no_progress)
                    .or(self.pkl.no_progress)
                    .or(self.defaults.no_progress);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            plan: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.plan
                    .or(self.env.plan)
                    .or(self.git.plan)
                    .or(self.pkl.plan)
                    .or(self.defaults.plan);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            profiles: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.profiles
                    .or(self.env.profiles)
                    .or(self.git.profiles)
                    .or(self.pkl.profiles)
                    .or(self.defaults.profiles);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
            quiet: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.quiet
                    .or(self.env.quiet)
                    .or(self.git.quiet)
                    .or(self.pkl.quiet)
                    .or(self.defaults.quiet);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            silent: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.silent
                    .or(self.env.silent)
                    .or(self.git.silent)
                    .or(self.pkl.silent)
                    .or(self.defaults.silent);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            skip_hooks: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: union
                let mut result = IndexSet::new();
                // Start with defaults
                if let Some(toml::Value::Array(arr)) = &self.defaults.skip_hooks {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add PKL values
                if let Some(toml::Value::Array(arr)) = &self.pkl.skip_hooks {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add git values
                if let Some(toml::Value::Array(arr)) = &self.git.skip_hooks {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add env values
                if let Some(toml::Value::Array(arr)) = &self.env.skip_hooks {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add CLI values
                if let Some(toml::Value::Array(arr)) = &self.cli.skip_hooks {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                result
            },
            skip_steps: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: union
                let mut result = IndexSet::new();
                // Start with defaults
                if let Some(toml::Value::Array(arr)) = &self.defaults.skip_steps {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add PKL values
                if let Some(toml::Value::Array(arr)) = &self.pkl.skip_steps {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add git values
                if let Some(toml::Value::Array(arr)) = &self.git.skip_steps {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add env values
                if let Some(toml::Value::Array(arr)) = &self.env.skip_steps {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                // Add CLI values
                if let Some(toml::Value::Array(arr)) = &self.cli.skip_steps {
                    for val in arr {
                        if let toml::Value::String(s) = val {
                            result.insert(s.clone());
                        }
                    }
                }
                result
            },
            slow: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.slow
                    .or(self.env.slow)
                    .or(self.git.slow)
                    .or(self.pkl.slow)
                    .or(self.defaults.slow);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            stash: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.stash
                    .or(self.env.stash)
                    .or(self.git.stash)
                    .or(self.pkl.stash)
                    .or(self.defaults.stash);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "auto".to_string())
            },
            stash_untracked: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.stash_untracked
                    .or(self.env.stash_untracked)
                    .or(self.git.stash_untracked)
                    .or(self.pkl.stash_untracked)
                    .or(self.defaults.stash_untracked);
                val.and_then(|v| v.as_bool()).unwrap_or(true)
            },
            state_dir: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.state_dir
                    .or(self.env.state_dir)
                    .or(self.git.state_dir)
                    .or(self.pkl.state_dir)
                    .or(self.defaults.state_dir);
                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from(""))
            },
            step: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.step
                    .or(self.env.step)
                    .or(self.git.step)
                    .or(self.pkl.step)
                    .or(self.defaults.step);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
            summary_text: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.summary_text
                    .or(self.env.summary_text)
                    .or(self.git.summary_text)
                    .or(self.pkl.summary_text)
                    .or(self.defaults.summary_text);
                val.and_then(|v| v.as_bool()).unwrap_or(false)
            },
            timing_json: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.timing_json
                    .or(self.env.timing_json)
                    .or(self.git.timing_json)
                    .or(self.pkl.timing_json)
                    .or(self.defaults.timing_json);
                val.and_then(|v| v.as_str().map(|s| PathBuf::from(s))).unwrap_or_else(|| PathBuf::from(""))
            },
            to_ref: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.to_ref
                    .or(self.env.to_ref)
                    .or(self.git.to_ref)
                    .or(self.pkl.to_ref)
                    .or(self.defaults.to_ref);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "".to_string())
            },
            trace: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.trace
                    .or(self.env.trace)
                    .or(self.git.trace)
                    .or(self.pkl.trace)
                    .or(self.defaults.trace);
                val.and_then(|v| v.as_str().map(|s| s.to_string())).unwrap_or_else(|| "off".to_string())
            },
            verbose: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.verbose
                    .or(self.env.verbose)
                    .or(self.git.verbose)
                    .or(self.pkl.verbose)
                    .or(self.defaults.verbose);
                val.and_then(|v| v.as_integer())
                    .and_then(|i| NonZero::new(i as usize))
                    .unwrap_or_else(|| NonZero::new(1).unwrap())
            },
            warnings: {
                // Precedence: CLI > env > git > PKL > defaults
                // Merge policy: replace
                let val = self.cli.warnings
                    .or(self.env.warnings)
                    .or(self.git.warnings)
                    .or(self.pkl.warnings)
                    .or(self.defaults.warnings);
                val.and_then(|v| v.as_array())
                    .map(|arr| arr.iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect())
                    .unwrap_or_else(IndexSet::new)
            },
        };

        let sources = SettingsSources {
            sources: self.sources,
        };

        (settings, sources)
    }
}

fn read_string_list(config: &git2::Config, key: &str) -> Result<IndexSet<String>, git2::Error> {
    let mut result = IndexSet::new();
    match config.multivar(key, None) {
        Ok(mut entries) => {
            while let Some(entry) = entries.next() {
                if let Some(value) = entry?.value() {
                    for item in value.split(',').map(|s| s.trim()) {
                        if !item.is_empty() {
                            result.insert(item.to_string());
                        }
                    }
                }
            }
        }
        Err(_) => {
            if let Ok(value) = config.get_string(key) {
                for item in value.split(',').map(|s| s.trim()) {
                    if !item.is_empty() {
                        result.insert(item.to_string());
                    }
                }
            }
        }
    }
    Ok(result)
}
