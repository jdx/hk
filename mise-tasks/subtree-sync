#!/usr/bin/env bash
# shellcheck shell=bash
set -euo pipefail

# Robust subtree sync utility for hk's subprojects.
#
# Usage:
#   mise run subtree-sync [--pull-only|--push-only] [--branch <name>] [--repos <comma list>]
#
# Defaults:
#   --branch main
#   --repos xx,clx,ensembler (only those present in the tree are processed)

trace() { printf "[subtree-sync] %s\n" "$*"; }

BRANCH="main"
MODE="both" # pull+push
REPOS="xx,clx,ensembler"
ANY_CHANGE=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --pull-only) MODE="pull"; shift ;;
    --push-only) MODE="push"; shift ;;
    --branch) BRANCH="${2:-main}"; shift 2 ;;
    --repos) REPOS="${2:-$REPOS}"; shift 2 ;;
    -h|--help)
      cat <<EOF
Usage: subtree-sync [--pull-only|--push-only] [--branch <name>] [--repos <comma list>]

Examples:
  mise run subtree-sync                    # pull and push xx, clx, ensembler
  mise run subtree-sync --pull-only        # only pull
  mise run subtree-sync --push-only        # only push
  mise run subtree-sync --branch main
  mise run subtree-sync --repos clx,ensembler
EOF
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      exit 2
      ;;
  esac
done

declare -A REPO_URLS
REPO_URLS[xx]="https://github.com/jdx/xx.git"
REPO_URLS[clx]="https://github.com/jdx/clx.git"
REPO_URLS[ensembler]="https://github.com/jdx/ensembler.git"

IFS=',' read -r -a REPO_LIST <<< "$REPOS"

# Ensure we're at repo root
if [[ ! -f Cargo.toml ]]; then
  echo "Run from repo root" >&2
  exit 1
fi

ensure_remote() {
  local remote_name="$1" remote_url="$2"
  if git remote get-url "$remote_name" >/dev/null 2>&1; then
    git remote set-url "$remote_name" "$remote_url"
  else
    git remote add "$remote_name" "$remote_url"
  fi
}

subtree_present() {
  local prefix="$1"
  git ls-tree "HEAD:${prefix}" >/dev/null 2>&1
}

pull_subtree() {
  local prefix="$1" remote_name="$2" branch="$3"
  trace "Pulling ${prefix} from ${remote_name}/${branch}"
  # Auto-stash if working tree is dirty to allow subtree pull
  local had_stash=0
  if ! git diff-index --quiet HEAD --; then
    had_stash=1
    trace "Working tree dirty; stashing changes"
    git stash push -u -k -m "subtree-sync:${prefix}:pre-pull" >/dev/null || true
  fi
  set +e
  git subtree pull --prefix="$prefix" "$remote_name" "$branch"
  local rc=$?
  set -e
  if [[ $had_stash -eq 1 ]]; then
    trace "Restoring stashed changes"
    git stash pop -q || trace "Stash pop reported conflicts; please resolve"
  fi
  return $rc
}

push_subtree() {
  local prefix="$1" remote_name="$2" branch="$3"
  trace "Preparing to push ${prefix} to ${remote_name}/${branch}"
  # Recompute split each time to ensure it includes any just-pulled commits
  local split_sha
  split_sha=$(git subtree split --prefix="$prefix" -q)
  # Fast-forward guard: ensure remote is ancestor of our split
  git fetch "$remote_name" "$branch"
  if git rev-parse --verify "$remote_name/$branch" >/dev/null 2>&1; then
    if ! git merge-base --is-ancestor "$remote_name/$branch" "$split_sha"; then
      trace "Remote ${remote_name}/${branch} has new commits; pulling before push"
      pull_subtree "$prefix" "$remote_name" "$branch"
      split_sha=$(git subtree split --prefix="$prefix" -q)
    fi
    # If remote already equals our split, there is nothing to push
    local remote_sha
    remote_sha=$(git rev-parse "$remote_name/$branch")
    if [[ "$remote_sha" == "$split_sha" ]]; then
      trace "No local changes to push for ${prefix}"
      return 3
    fi
  fi
  trace "Pushing ${prefix} split ${split_sha} to ${remote_name}/${branch}"
  git push "$remote_name" "$split_sha:$branch"
}

for repo in "${REPO_LIST[@]}"; do
  repo="${repo// /}"
  [[ -z "$repo" ]] && continue

  url="${REPO_URLS[$repo]:-}"
  if [[ -z "$url" ]]; then
    trace "Skipping unknown repo key: $repo"
    continue
  fi

  if ! subtree_present "$repo"; then
    trace "Skipping ${repo}: not present in this commit"
    continue
  fi

  if [[ -d "$repo/.git" ]]; then
    echo "Error: ${repo} contains an embedded .git directory; not a subtree" >&2
    exit 1
  fi

  remote_name="subtree_${repo}"
  ensure_remote "$remote_name" "$url"
  git fetch "$remote_name" "$BRANCH" || true
  # Ensure refs/remotes/<remote>/HEAD exists to satisfy hooks that expect it
  git remote set-head "$remote_name" "$BRANCH" >/dev/null 2>&1 || true

  case "$MODE" in
    pull)
      before_head=$(git rev-parse HEAD)
      if pull_subtree "$repo" "$remote_name" "$BRANCH"; then
        after_head=$(git rev-parse HEAD)
        if [[ "$before_head" != "$after_head" ]]; then
          ANY_CHANGE=1
        else
          trace "No changes pulled for ${repo}"
        fi
      else
        trace "No changes pulled for ${repo}"
      fi
      ;;
    push)
      if push_subtree "$repo" "$remote_name" "$BRANCH"; then
        ANY_CHANGE=1
      else
        trace "No changes pushed for ${repo}"
      fi
      ;;
    both)
      before_head=$(git rev-parse HEAD)
      if pull_subtree "$repo" "$remote_name" "$BRANCH"; then
        after_head=$(git rev-parse HEAD)
        if [[ "$before_head" != "$after_head" ]]; then
          ANY_CHANGE=1
        else
          trace "No changes pulled for ${repo}"
        fi
      else
        trace "No changes pulled for ${repo}"
      fi
      if push_subtree "$repo" "$remote_name" "$BRANCH"; then
        ANY_CHANGE=1
      else
        trace "No changes pushed for ${repo}"
      fi
      ;;
  esac
done

if [[ $ANY_CHANGE -eq 0 ]]; then
  trace "No subtree changes detected. Nothing to do."
  exit 0
fi

trace "Done"
